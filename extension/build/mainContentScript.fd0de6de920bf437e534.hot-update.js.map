{"version":3,"file":"mainContentScript.fd0de6de920bf437e534.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AACA;;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAAA;AAEA;;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;;AAvFA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AA2FA;AAAA;;;;;;;;;;AA3FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;;AAGA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAtEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AA2EA;AAAA;;;;;;;;;;AA3EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AAGA;AAEA;AACA;AACA;AAYA;AAOA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AA3EA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;;AAGA;AACA;AACA;AAEA;AACA;AACA;;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAwEA;AAAA;;;;;;;;;;AAxEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA","sources":["webpack://fix-your-netflix-experiment-extension/./src/pages/Content/main/modules/BitrateController.js","webpack://fix-your-netflix-experiment-extension/./src/pages/Content/main/modules/BufferResetter.js","webpack://fix-your-netflix-experiment-extension/./src/pages/Content/main/modules/CustomPlayer.js","webpack://fix-your-netflix-experiment-extension/./src/pages/Content/main/modules/QualityScenarioManager.js","webpack://fix-your-netflix-experiment-extension/./src/pages/Content/main/modules/StatsAnalyzer.ts","webpack://fix-your-netflix-experiment-extension/./src/pages/Content/utils/BitrateMenu.ts","webpack://fix-your-netflix-experiment-extension/./src/pages/Content/utils/StatisticsMenu.ts","webpack://fix-your-netflix-experiment-extension/./src/utils/CustomLogger.ts","webpack://fix-your-netflix-experiment-extension/webpack/runtime/getFullHash"],"sourcesContent":["import {BitrateMenu} from \"../../utils/BitrateMenu\";\nimport {CustomLogger} from \"../../../../utils/CustomLogger\";\nimport {STORAGE_KEYS} from \"../../../../config/config\";\nimport {get_local_datetime} from \"../../../../utils/time_utils\";\nimport {send_bitrate} from \"../../../../utils/http_requests/send_bitrate\";\nimport BufferResetter from \"./BufferResetter\";\nimport {wait_for_video_to_load} from \"../../utils/wait_for_video_to_load\";\n\nclass BitrateController{\n    scenario; interval; iterator; bitrate_menu; logger; buffer_resetter;\n\n    constructor(scenario, interval, bitrate_menu, iterator) {\n        this.scenario = scenario\n        this.interval = interval\n        this.iterator = iterator\n        this.bitrate_menu = bitrate_menu\n\n        this.logger = new CustomLogger(\"[BitrateController]\")\n        this.buffer_resetter = new BufferResetter()\n    }\n\n    async init(){\n        await wait_for_video_to_load()\n\n        await this.set_bitrate()    // First bitrate set after video is loaded\n\n        await this.buffer_resetter.reset()  // Navigating to the start and resetting buffer\n\n        await this.set_bitrate()    // Second bitrate set after buffer is reset\n\n        this.start_bitrate_change_interval()    // Scheduling the rest of bitrate changes using setInterval\n    }\n\n\n\n    /**\n     * Universal method for setting the next bitrate value in order.\n     * Order of bitrates is defined by video's scenario.\n     * @returns {Promise<void>}\n    */\n    async set_bitrate() {\n        const settings = this.iterator.next().value\n        this.logger.log(`Setting bitrate to ${settings.bitrate}kbps which corresponds to VMAF ${settings.vmaf}`)\n        this.logger.log(`VMAF template was ${settings.vmaf_template}. Difference: ${settings.vmaf_diff}`)\n\n        await this.execute_bitrate_change(settings.bitrate)\n    }\n\n    /**\n     * Executes bitrate change by invoking actual bitrate menu,\n     * validating selected bitrate and overriding the settings\n     * @param bitrate<number>\n     * @returns {Promise<void>}\n    */\n    async execute_bitrate_change(bitrate) {\n        // Invoke bitrate menu\n        await this.bitrate_menu.invoke_bitrate_menu()   // ESSENTIAL --> bitrate menu has to be invoked before simulating clicks and changing bitrate\n        // Validate selected bitrate\n        const bitrate_validated = this.bitrate_menu.check_bitrate_availability(bitrate)\n        // Set bitrate\n        await this.bitrate_menu.set_bitrate(bitrate_validated)\n        // Send bitrate change update to backend server\n        await this.send_bitrate_change_update(bitrate_validated)\n    }\n\n    /**\n     * Prepares data and sends post request to REST API\n     * with information on new bitrate change.\n     * Also updates chrome.storage with current bitrate\n     * @param {Number} bitrate\n    */\n    async send_bitrate_change_update(bitrate) {\n        // Get previous bitrate and send update\n        const res = await chrome.storage.local.get([STORAGE_KEYS.CURRENT_BITRATE, STORAGE_KEYS.DATABASE_VIDEO_ID])\n        const bitrate_data = {\n            video_id: res[STORAGE_KEYS.DATABASE_VIDEO_ID],\n            previous: res[STORAGE_KEYS.CURRENT_BITRATE],\n            timestamp: get_local_datetime(new Date()),\n            value: bitrate\n        }\n        /*await */send_bitrate(bitrate_data) // <-- not waiting for response\n\n        // Save new current bitrate value to chrome.storage\n        await chrome.storage.local.set({\n            [STORAGE_KEYS.CURRENT_BITRATE]: bitrate\n        })\n    }\n\n    /**\n     * Starts bitrate change interval\n    */\n    start_bitrate_change_interval(){\n        setInterval(async () => {\n            await this.set_bitrate()\n        }, this.interval)\n    }\n}\n\n\nexport default BitrateController","import {CustomLogger} from \"../../../../utils/CustomLogger\";\n\n\nclass BufferResetter{\n    constructor() {\n        this.logger = new CustomLogger(\"[BufferResetter]\")\n        this.inject_code()\n    }\n\n\n    async reset(){\n        let interval = undefined\n        const delay = 333\n\n        return new Promise(resolve => {\n            interval = setInterval(async () => {\n                const seek_element = document.getElementById(\"seek_element\")\n                const video = document.getElementsByTagName(\"video\")[0]\n\n                if(seek_element != null && video != null){\n                    clearInterval(interval) // Clear interval immediately !!!\n\n                    // Pause, mute and hide video as soon as possible\n                    video.style.opacity = \"0\"\n                    video.pause()\n                    video.muted = true\n\n                    // Proceed with resetting\n                    await new Promise(resolve => {\n                        setTimeout(() => {\n                            this.logger.log(\"Navigating to 1000th second of video\")\n                            seek_element.setAttribute(\"timestamp\", String(1000))\n                            seek_element.click()\n                            resolve()\n                        }, delay)\n                    })\n\n                    await new Promise(resolve => {\n                        setTimeout(() => {\n                            this.logger.log(\"Navigating to the very beginning of the video\")\n                            seek_element.setAttribute(\"timestamp\", String(0))\n                            seek_element.click()\n                            resolve()\n                        }, delay)\n                    })\n\n                    await new Promise(resolve => {\n                       setTimeout(() => {\n                           this.logger.log(\"Resuming normal playback\")\n                           video.muted = false\n                           video.style.opacity = \"1\"\n                           video.play()\n                           resolve()\n                       }, delay)\n                    })\n\n                    resolve()\n                }\n                else{\n                    // nothing, try again\n                }\n            }, 10)\n        })\n    }\n\n\n    inject_code(){\n        this.logger.log(\"Injecting netflixControls.bundle.js script into the page\")\n        const s = document.createElement('script');\n        s.src = chrome.runtime.getURL(\"netflixControls.bundle.js\");\n\n        (document.head || document.documentElement).appendChild(s);\n        s.remove()\n    }\n}\n\n\n\nexport default BufferResetter","import {wait_for_video_to_load} from \"../../utils/wait_for_video_to_load\";\nimport {CustomLogger} from \"../../../../utils/CustomLogger\";\n\n\nexport class CustomPlayer{\n\n    constructor() {\n        this.logger = new CustomLogger(\"[CustomPlayer]\")\n        this.elements_to_remove = [\n            \"control-play-pause-pause\",\n            \"control-play-pause-play\",\n            \"control-back10\",\n            \"control-forward10\",\n            \"control-speed\",\n            \"control-fullscreen-enter\",\n            \"control-fullscreen-exit\",\n            \"control-episodes\",\n            \"control-next\",\n            \"timeline-bar\"\n        ]\n        this.elements_to_leave = [\n            \"control-volume-off\",\n            \"control-volume-low\",\n            \"control-volume-medium\",\n            \"control-volume-high\",\n            \"control-audio-subtitle\"\n        ]\n    }\n\n    async init(){\n        await wait_for_video_to_load()\n\n        await this.create_shutter()\n\n        const video_canvas = document.querySelectorAll(\"[data-uia='video-canvas']\")[0]\n        video_canvas.addEventListener(\"mousemove\", () => {\n            let controls_container = document.getElementsByClassName(\"watch-video--bottom-controls-container\")[0]\n\n            this.elements_to_remove.forEach(element_data_uia => {\n                const element = this.get_element(controls_container, element_data_uia)\n                if(element) element.remove()\n            })\n\n            this.elements_to_leave.forEach(element_data_uia => {\n                const element = this.get_element(controls_container, element_data_uia)\n                if(element) this.modify_element(element)\n            })\n        })\n    }\n\n    modify_element(element){\n        element.style.zIndex = \"10100\"\n        element.parentNode.style.zIndex = \"10100\"\n    }\n\n    get_element(container, element_data_uia){\n        const selector = `[data-uia='${element_data_uia}']`\n        return container.querySelectorAll(selector)[0]\n    }\n\n    async create_shutter(){\n        const video_canvas = document.querySelectorAll(\"[data-uia='video-canvas']\")[0]\n\n        const shutter = document.createElement(\"div\")\n        shutter.id = \"transparent_panel\"\n\n        shutter.style.width = \"100vw\"; shutter.style.height = \"100vh\";\n        shutter.style.position = \"absolute\"; shutter.style.left= \"0\"; shutter.style.top = \"0\";\n        shutter.style.backgroundColor= \"lightblue\";\n        shutter.style.display = \"flex\";\n        shutter.style.justifyContent = \"center\"; shutter.style.alignItems = \"center\"; shutter.style.flexDirection = \"column\"\n        shutter.style.zIndex = \"10000\"\n        shutter.style.opacity = \"0\"\n\n        shutter.onclick = (e) => {\n            e.stopPropagation()\n        }\n\n        video_canvas.appendChild(shutter)\n    }\n}","import { CONFIGURATION_KEYS, STORAGE_KEYS } from \"../../../../config/config\";\nimport { BITRATE_INTERVAL } from \"../../../../config/config\";\nimport { CustomLogger } from \"../../../../utils/CustomLogger\";\nimport BitrateController from \"./BitrateController\";\nimport {BitrateMenu} from \"../../utils/BitrateMenu\";\n\nexport class QualityScenarioManager {\n    scenario\n    bitrate_interval\n    logger\n    bitrate_menu\n    iterator\n    bitrate_controller\n\n    async init(){\n        this.bitrate_menu = new BitrateMenu()\n        await this.bitrate_menu.init()\n\n        this.logger = new CustomLogger(\"[QualityScenarioManager]\")\n\n        this.scenario = await this.prepare_video_scenario()\n\n        this.bitrate_interval = await this.prepare_bitrate_interval()\n\n        this.iterator = this.scenario_iterator()\n\n        // Start bitrate changes\n        this.bitrate_controller = new BitrateController(this.scenario, this.bitrate_interval, this.bitrate_menu, this.iterator)\n        await this.bitrate_controller.init()\n    }\n\n    /**\n     *  Method reads bitrate changes interval from config file. Provided in seconds has to be converted to ms.\n     */\n    async prepare_bitrate_interval() {\n        const configuration = (await chrome.storage.local.get([STORAGE_KEYS.CONFIGURATION]))[STORAGE_KEYS.CONFIGURATION]\n        const interval_s = configuration[CONFIGURATION_KEYS.BITRATE_INTERVAL]\n\n        if (interval_s != null && typeof (interval_s) == 'number') {\n            this.logger.log(`Configuration's bitrate change interval - OK, ${interval_s}s = ${this.bitrate_interval}ms`)\n            return 1000 * interval_s\n        } else {\n            this.logger.log(`Configuration's bitrate change interval missing or incorrect. Using default interval`)\n            return BITRATE_INTERVAL\n        }\n    }\n\n    /**\n     *  Method prepares scenario for current video.\n     *  Fetches configuration from chrome.storage.\n     */\n    async prepare_video_scenario() {\n        const storage = await chrome.storage.local.get([STORAGE_KEYS.CONFIGURATION, STORAGE_KEYS.VIDEO_COUNT])\n        const configuration = storage[STORAGE_KEYS.CONFIGURATION]\n        const video_count = storage[STORAGE_KEYS.VIDEO_COUNT]\n        const video_index = video_count - 1\n\n        return configuration[CONFIGURATION_KEYS.VIDEOS][video_index][CONFIGURATION_KEYS.VIDEO_KEYS.SCENARIO]\n    }\n\n    /**\n     * Yields scenario's items in loop\n     */\n    * scenario_iterator() {\n        let index = 0;\n        while (true) {\n            this.logger.log(\"Yielding...\")\n            this.logger.log(this.scenario[index])\n            yield this.scenario[index]\n            if (index >= this.scenario.length - 1) {\n                index = 0\n            } else {\n                index += 1\n            }\n        }\n    }\n}\n\nexport default QualityScenarioManager","import { ARCHIVE_KEYS, MESSAGE_TEMPLATE, MESSAGE_HEADERS } from \"../../../../config/config\";\nimport { STATS_RECORD_INTERVAL_MS } from \"../../../../config/config\";\nimport { get_local_datetime } from \"../../../../utils/time_utils\";\nimport { send_playback_data } from \"../../../../utils/http_requests/send_playback_data\";\nimport { StatisticsMenu } from \"../../utils/StatisticsMenu\";\nimport { CustomLogger } from \"../../../../utils/CustomLogger\";\nexport class StatsAnalyzer {\n    constructor() {\n        this.init = async () => {\n            this.logger.log(`Initializing...`);\n            // Create StatisticsMenu class instance\n            this.stats_menu = new StatisticsMenu();\n            await this.stats_menu.init();\n            // Start recording playback statistics\n            await this.start_recording();\n        };\n        this.start_recording = async () => {\n            this.interval = setInterval(async () => {\n                if (this.stats_menu == null) {\n                    return;\n                }\n                const timestamp = get_local_datetime(new Date());\n                const data = this.stats_menu.analyze_statistics_text();\n                data.timestamp = timestamp;\n                const archive = this.compile_archive(this.stats_menu.get_statistics_text(), timestamp);\n                // Send playback data to backend\n                // NOT USING await --> not waiting for response\n                /*await*/ send_playback_data(data, archive);\n                // Check if credits are available and remove container\n                await this.are_credits_available();\n            }, STATS_RECORD_INTERVAL_MS);\n        };\n        this.compile_archive = (data, timestamp) => {\n            return {\n                [ARCHIVE_KEYS.DATA]: data,\n                [ARCHIVE_KEYS.TIMESTAMP]: timestamp\n            };\n        };\n        this.logger = new CustomLogger(\"[StatsAnalyzer]\");\n    }\n    /**\n     * This method checks if certain HTML elements are available in DOM tree.\n     * Their availability indicates that serie's video is about to end and credits are present.\n     * If elements are detected video playback ends and subject is redirected to custom extension's web page\n    */\n    async are_credits_available() {\n        const outer_container = document.getElementsByClassName(\"nfa-pos-abs nfa-bot-6-em nfa-right-5-em nfa-d-flex\")[0];\n        // data-uia = \"watch-credits-seamless-button\"   // Leave this for reference purpose\n        // data-uia=\"next-episode-seamless-button\"      // Leave this for reference purpose\n        // Checking PlayerSpace class element in case of last episode of the last season\n        const player_space = document.getElementsByClassName(\"PlayerSpace\")[0];\n        // This element is displayed when last video of last season is played or a standalone movie\n        const back_to_browse = document.getElementsByClassName(\"BackToBrowse\")[0];\n        if (back_to_browse) {\n            clearInterval(this.interval);\n            // Pause the video\n            document.getElementsByTagName(\"video\")[0].pause();\n            // Send FINISHED signal to the BackgroundScript\n            await chrome.runtime.sendMessage({\n                [MESSAGE_TEMPLATE.HEADER]: MESSAGE_HEADERS.FINISHED,\n                [MESSAGE_TEMPLATE.DATA]: true\n            });\n        }\n        else if (player_space) {\n            // Stop analyzing\n            clearInterval(this.interval);\n            // Pause the video\n            document.getElementsByTagName(\"video\")[0].pause();\n            // Send FINISHED signal to the BackgroundScript\n            await chrome.runtime.sendMessage({\n                [MESSAGE_TEMPLATE.HEADER]: MESSAGE_HEADERS.FINISHED,\n                [MESSAGE_TEMPLATE.DATA]: true\n            });\n        }\n        else if (outer_container) {\n            // Click watch credits button\n            const credits_button = document.querySelectorAll('[data-uia=\"watch-credits-seamless-button\"]')[0];\n            credits_button.click();\n            outer_container.remove(); // remove container\n            // Stop analyzing\n            clearInterval(this.interval);\n            // Pause the video\n            document.getElementsByTagName(\"video\")[0].pause();\n            // Send FINISHED signal to the BackgroundScript\n            await chrome.runtime.sendMessage({\n                [MESSAGE_TEMPLATE.HEADER]: MESSAGE_HEADERS.FINISHED,\n                [MESSAGE_TEMPLATE.DATA]: true\n            });\n        }\n    }\n}\n","import { CustomLogger } from \"../../../utils/CustomLogger\";\nimport { invoke_bitrate_menu_and_get_html_elements } from \"./get_bitrate_menu_elements\";\nimport { simulate_bitrate_menu_hotkey } from \"./keyboard_hotkeys/simulate_bitrate_menu_hotkeys\";\nexport class BitrateMenu {\n    constructor() {\n        /**\n         *  Invokes bitrate menu and assings bitrate menu's HTML elements\n         *  to instance attributes.\n         *  Closes bitrate menu by simulating click event on Reset button.\n        */\n        this.init = async () => {\n            await this.invoke_bitrate_menu();\n            //this.reset_button.click()   <-- alternative way of closing the menu but it also resets the bitrates\n            simulate_bitrate_menu_hotkey(); // Close bitrate menu after initialization is finished\n        };\n        /**\n         *  Invokes bitrate_menu and reassigns HTML elements\n         *  Reassigning elements is important because bitrate menu is removed from DOM tree\n         *  after overriding bitrate value or reseting\n        */\n        this.invoke_bitrate_menu = async () => {\n            this.logger.log(\"Invoking bitrate menu...\");\n            // Invoke bitrate menu and get html elements\n            this.bitrate_menu_elements = await invoke_bitrate_menu_and_get_html_elements();\n            this.available_bitrates = this.bitrate_menu_elements.bitrate_values;\n            this.override_button = this.bitrate_menu_elements.override_button;\n            this.reset_button = this.bitrate_menu_elements.reset_button;\n            this.select = this.bitrate_menu_elements.select;\n            this.logger.log(\"Bitrate menu invoked.\");\n        };\n        /**\n         * Returns array of available bitrate values\n         * @returns {Array<number>} Available bitrate values\n        */\n        this.get_available_bitrates = () => {\n            return this.available_bitrates;\n        };\n        /**\n         * Returns HTML elements of bitrate menu\n         * @returns {T_BITRATE_MENU_ELEMENTS}\n        */\n        this.get_bitrate_menu_elements = () => {\n            if (this.bitrate_menu_elements) {\n                return this.bitrate_menu_elements;\n            }\n        };\n        /**\n         * Method checks if provided bitrate is available in bitrate menu.\n         * If it is then the same value is returned.\n         * If not - the closest value is found and returned.\n         * @param {number} bitrate\n         * @returns {number} Returns closest available bitrate to provided value\n        */\n        this.check_bitrate_availability = (bitrate) => {\n            if (this.available_bitrates.includes(bitrate)) {\n                return bitrate;\n            }\n            else {\n                this.logger.log(\"Provided bitrate is not available. Finding closest value...\");\n                const closest_bitrate = this.available_bitrates.reduce((prev, curr) => {\n                    return (Math.abs(curr - bitrate) < Math.abs(prev - bitrate) ? curr : prev);\n                });\n                this.logger.log(`Closest bitrate to ${bitrate} is ${closest_bitrate}`);\n                return closest_bitrate;\n            }\n        };\n        this.available_bitrates = [];\n        this.logger = new CustomLogger(\"[BitrateMenu]\");\n    }\n    /**\n     * Overrides current bitrate with new bitrate value\n     * provided as a parameter\n     * @param {number} bitrate\n    */\n    async set_bitrate(bitrate) {\n        if (this.select && this.override_button) {\n            this.logger.log(`Setting bitrate to: ${bitrate}`);\n            this.select.value = bitrate.toString();\n            this.logger.log(`SELECTED BITRATE VALUE: ${this.select.value}`);\n            this.override_button.click();\n        }\n    }\n}\n","import { get_statistics_element } from \"./get_statistics_element\";\nimport { CustomLogger } from \"../../../utils/CustomLogger\";\nexport class StatisticsMenu {\n    constructor() {\n        /**\n         *  Prepares for further actions\n        */\n        this.init = async () => {\n            await this.invoke_statistics_menu();\n        };\n        /**\n         *  Invokes statistics menu to the screen\n         *  and assigns statistics element to the instance's attribute\n        */\n        this.invoke_statistics_menu = async () => {\n            this.stats_element = await get_statistics_element();\n        };\n        /**\n         * Returns statistics element's value parsed to string.\n         * It can be further analyzed using regular expressions.\n         * @returns {string}\n        */\n        this.get_statistics_text = () => {\n            if (this.stats_element)\n                return this.stats_element.value.toString();\n        };\n        /**\n         * Creates object with information retrieved from nerd statistics string value.\n         * @returns {object} Object with key - parameter name, values - parameter's value\n         * eg.\n         * {    ...\n         *      buffering_vmaf: 90,\n         *      buffering_bitrate_video: 2550\n         *      ...\n         * }\n        */\n        this.analyze_statistics_text = () => {\n            if (this.stats_element == null) {\n                return;\n            }\n            const text = this.stats_element.value.toString();\n            const data = {\n                position: this.get_value(\"(Position:) ([0-9]+.[0-9]+)\", 2, text),\n                volume: this.get_value(\"(Volume:) ([0-9]+)%\", 2, text),\n                segment_position: this.get_value(\"(Segment Position:) ([0-9]+.[0-9]+)\", 2, text),\n                player_state: this.get_value(\"(Player state: )([a-zA-Z]+)\", 2, text),\n                buffering_state: this.get_value(\"(Buffering state:) (.+)\", 2, text),\n                rendering_state: this.get_value(\"(Rendering state:) (.+)\", 2, text),\n                playing_bitrate_audio: this.get_value(\"Playing bitrate \\\\(a\\\\/v\\\\):\\\\s*([0-9]+)\\\\s*\\\\/\\\\s*([0-9]+)\", 1, text),\n                playing_bitrate_video: this.get_value(\"Playing bitrate \\\\(a\\\\/v\\\\):\\\\s*([0-9]+)\\\\s*\\\\/\\\\s*([0-9]+)\", 2, text),\n                resolution: this.get_value(\"([0-9]+x[0-9]+)\", 1, text),\n                playing_vmaf: this.get_value(\"Playing\\/Buffering vmaf: ([0-9]+)\\s*\\/\\s*([0-9]+)\", 1, text),\n                buffering_vmaf: this.get_value(\"Playing\\/Buffering vmaf: ([0-9]+)\\s*\\/\\s*([0-9]+)\", 2, text),\n                buffering_bitrate_audio: this.get_value(\"Buffering bitrate \\\\(a\\\\/v\\\\):\\\\s*([0-9]+)\\\\s*\\\\/\\\\s*([0-9]+)\", 1, text),\n                buffering_bitrate_video: this.get_value(\"Buffering bitrate \\\\(a\\\\/v\\\\):\\\\s*([0-9]+)\\\\s*\\\\/\\\\s*([0-9]+)\", 2, text),\n                total_frames: this.get_value(\"Total Frames:\\\\s*([0-9]+)\", 1, text),\n                total_dropped_frames: this.get_value(\"Total Dropped Frames:\\\\s*([0-9]+)\", 1, text),\n                total_corrupted_frames: this.get_value(\"Total Corrupted Frames:\\\\s*([0-9]+)\", 1, text),\n                framerate: this.get_value(\"Framerate: ([0-9]+.[0-9]+)\", 1, text),\n                duration: this.get_value(\"(Duration:) ([0-9]+.[0-9]+)\", 2, text),\n                timestamp: null\n            };\n            return data;\n        };\n        /**\n         * Utility method --> extracts useful data from nerds stats (long) string\n         * @param {string} regex\n         * @param {number} group\n         * @param {string} data\n         * @returns {object|null}\n         */\n        this.get_value = (regex, group, data) => {\n            try {\n                let value = data.match(regex) ?? null;\n                if (value != null) {\n                    return value[group];\n                }\n                else {\n                    return null;\n                }\n            }\n            catch (e) {\n                this.logger.log(e);\n                return null;\n            }\n        };\n        this.logger = new CustomLogger(\"[StatisticsMenu]\");\n    }\n}\n","import { get_local_datetime } from \"./time_utils\";\nexport class CustomLogger {\n    constructor(prefix) {\n        this.log = (content) => {\n            const prefix_date = `${this.prefix} | ${get_local_datetime(new Date())} |`;\n            this.original_logger(prefix_date, content);\n        };\n        this.prefix = prefix;\n        this.original_logger = console.log;\n    }\n}\n","__webpack_require__.h = () => (\"370632cd0774a17088c5\")"],"names":[],"sourceRoot":""}