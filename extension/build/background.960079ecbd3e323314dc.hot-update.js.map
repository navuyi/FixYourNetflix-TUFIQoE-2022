{"version":3,"file":"background.960079ecbd3e323314dc.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AApFA;AA8FA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAhFA;AA0FA;AA5LA;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AATA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://fix-your-netflix-experiment-extension/./src/config/default_experiment_config.js","webpack://fix-your-netflix-experiment-extension/./src/utils/CustomLogger.js","webpack://fix-your-netflix-experiment-extension/./src/config/config.ts","webpack://fix-your-netflix-experiment-extension/./src/pages/Background/index.ts","webpack://fix-your-netflix-experiment-extension/./src/pages/Background/modules/Controller.ts","webpack://fix-your-netflix-experiment-extension/./src/utils/time_utils.ts","webpack://fix-your-netflix-experiment-extension/webpack/runtime/define property getters","webpack://fix-your-netflix-experiment-extension/webpack/runtime/getFullHash","webpack://fix-your-netflix-experiment-extension/webpack/runtime/harmony module decorator","webpack://fix-your-netflix-experiment-extension/webpack/runtime/make namespace object"],"sourcesContent":["export const DEFAULT_EXPERIMENT_CONFIGURATION = {\n  \"assessment_interval\": 150,\n  \"bitrate_interval\": 150,\n  \"description\": \"can be left as empty string\",\n  \"videos\": [\n    {\n      \"bitrate_vmaf_map\": [\n        {\n          \"bitrate\": 80,\n          \"vmaf\": \"37\"\n        },\n        {\n          \"bitrate\": 100,\n          \"vmaf\": \"43\"\n        },\n        {\n          \"bitrate\": 141,\n          \"vmaf\": \"52\"\n        },\n        {\n          \"bitrate\": 218,\n          \"vmaf\": \"63\"\n        },\n        {\n          \"bitrate\": 338,\n          \"vmaf\": \"71\"\n        },\n        {\n          \"bitrate\": 601,\n          \"vmaf\": \"79\"\n        },\n        {\n          \"bitrate\": 1149,\n          \"vmaf\": \"85\"\n        },\n        {\n          \"bitrate\": 2472,\n          \"vmaf\": \"88\"\n        },\n        {\n          \"bitrate\": 3439,\n          \"vmaf\": \"89\"\n        },\n        {\n          \"bitrate\": 5147,\n          \"vmaf\": \"90\"\n        }\n      ],\n      \"description\": \"Lorem ipsum\",\n      \"name\": \"Narcos_s01_e04\",\n      \"scenario\": [\n        {\n          \"bitrate\": 80,\n          \"vmaf\": 37,\n          \"vmaf_diff\": 17,\n          \"vmaf_template\": 20\n        },\n        {\n          \"bitrate\": 141,\n          \"vmaf\": 52,\n          \"vmaf_diff\": 2,\n          \"vmaf_template\": 50\n        },\n        {\n          \"bitrate\": 80,\n          \"vmaf\": 37,\n          \"vmaf_diff\": 17,\n          \"vmaf_template\": 20\n        },\n        {\n          \"bitrate\": 5147,\n          \"vmaf\": 90,\n          \"vmaf_diff\": 0,\n          \"vmaf_template\": 90\n        },\n        {\n          \"bitrate\": 100,\n          \"vmaf\": 43,\n          \"vmaf_diff\": 2,\n          \"vmaf_template\": 45\n        },\n        {\n          \"bitrate\": 141,\n          \"vmaf\": 52,\n          \"vmaf_diff\": 1,\n          \"vmaf_template\": 51\n        }\n      ],\n      \"url\": \"https://www.netflix.com/watch/70196252?trackId=14170286\",\n      \"vmaf_template_scenario\": [\n        20,\n        50,\n        20,\n        90,\n        45,\n        51\n      ]\n    },\n    {\n      \"bitrate_vmaf_map\": [\n        {\n          \"bitrate\": 86,\n          \"vmaf\": \"40\"\n        },\n        {\n          \"bitrate\": 106,\n          \"vmaf\": \"46\"\n        },\n        {\n          \"bitrate\": 146,\n          \"vmaf\": \"55\"\n        },\n        {\n          \"bitrate\": 233,\n          \"vmaf\": \"67\"\n        },\n        {\n          \"bitrate\": 369,\n          \"vmaf\": \"76\"\n        },\n        {\n          \"bitrate\": 623,\n          \"vmaf\": \"84\"\n        },\n        {\n          \"bitrate\": 976,\n          \"vmaf\": \"89\"\n        },\n        {\n          \"bitrate\": 1571,\n          \"vmaf\": \"92\"\n        },\n        {\n          \"bitrate\": 3083,\n          \"vmaf\": \"95\"\n        }\n      ],\n      \"description\": \"Lorem ipsum\",\n      \"name\": \"Narcos_s02_e02\",\n      \"scenario\": [\n        {\n          \"bitrate\": 86,\n          \"vmaf\": 40,\n          \"vmaf_diff\": 20,\n          \"vmaf_template\": 20\n        },\n        {\n          \"bitrate\": 106,\n          \"vmaf\": 46,\n          \"vmaf_diff\": 4,\n          \"vmaf_template\": 50\n        },\n        {\n          \"bitrate\": 86,\n          \"vmaf\": 40,\n          \"vmaf_diff\": 20,\n          \"vmaf_template\": 20\n        },\n        {\n          \"bitrate\": 976,\n          \"vmaf\": 89,\n          \"vmaf_diff\": 1,\n          \"vmaf_template\": 90\n        },\n        {\n          \"bitrate\": 106,\n          \"vmaf\": 46,\n          \"vmaf_diff\": 1,\n          \"vmaf_template\": 45\n        },\n        {\n          \"bitrate\": 146,\n          \"vmaf\": 55,\n          \"vmaf_diff\": 4,\n          \"vmaf_template\": 51\n        }\n      ],\n      \"url\": \"https://www.netflix.com/watch/80101274?trackId=14170286\",\n      \"vmaf_template_scenario\": [\n        20,\n        50,\n        20,\n        90,\n        45,\n        51\n      ]\n    }\n  ],\n  \"title\": \"This is my config for development purposes\"\n}","import { get_local_datetime } from \"./time_utils\"\n\n\nexport class CustomLogger{\n    constructor(prefix){\n        this.prefix = prefix\n        this.original_logger = console.log\n    }\n\n    log = (content) => {\n        const prefix_date = `${this.prefix} | ${get_local_datetime(new Date())} |`\n        this.original_logger(prefix_date, content)\n    }\n}","import { DEFAULT_EXPERIMENT_CONFIGURATION } from \"./default_experiment_config\";\nexport const STATS_RECORD_INTERVAL_MS = 1000; //1000 <---\nexport const STATS_NONCLICKABLE = true;\nexport const STATS_INVISIBLE = false;\nexport const BITRATE_INTERVAL = 5 * 60 * 1000; // <--- 5 minutes = 5*60*1000\nexport const ASSESSMENT_INTERVAL = 2.5 * 60 * 1000; // <--- 2.5*60*1000\nexport const DATABASE_KEYS = {\n    POSITION: 'position',\n    DURATION: 'duration',\n    VOLUME: 'volume',\n    SEGMENT_POSITION: 'segment_position',\n    PLAYER_STATE: 'player_state',\n    BUFFERING_STATE: 'buffering_state',\n    RENDERING_STATE: 'rendering_state',\n    PLAYING_BITRATE_AUDIO: 'playing_bitrate_audio',\n    PLAYING_BITRATE_VIDEO: 'playing_bitrate_video',\n    RESOLUTION: 'resolution',\n    PLAYING_VMAF: 'playing_vmaf',\n    BUFFERING_VMAF: 'buffering_vmaf',\n    BUFFERING_BITRATE_AUDIO: 'buffering_bitrate_audio',\n    BUFFERING_BITRATE_VIDEO: 'buffering_bitrate_video',\n    TOTAL_FRAMES: 'total_frames',\n    TOTAL_DROPPED_FRAMES: 'total_dropped_frames',\n    TOTAL_CORRUPTED_FRAMES: 'total_corrupted_frames',\n    FRAMERATE: 'framerate',\n    TIMESTAMP: 'timestamp',\n};\nexport const ARCHIVE_KEYS = {\n    DATA: 'data',\n    TIMESTAMP: 'timestamp',\n};\nexport const ARCHIVE_DEFAULT = {\n    [ARCHIVE_KEYS.DATA]: [],\n    [ARCHIVE_KEYS.TIMESTAMP]: [],\n};\nexport const ASSESSMENTS_KEYS = {\n    VALUE: 'value',\n    DESCRIPTION: 'description',\n    TIMESTAMP: 'timestamp',\n    STARTED: 'started',\n    DURATION: 'duration',\n};\nexport const ASSESSMENTS_DEFAULT = {\n    [ASSESSMENTS_KEYS.VALUE]: [],\n    [ASSESSMENTS_KEYS.DESCRIPTION]: [],\n    [ASSESSMENTS_KEYS.TIMESTAMP]: [],\n    [ASSESSMENTS_KEYS.STARTED]: [],\n    [ASSESSMENTS_KEYS.DURATION]: [],\n};\nexport const STORAGE_KEYS = {\n    DATA_TO_SAVE: 'data_to_save',\n    ARCHIVE_TO_SAVE: 'archive_to_save',\n    ASSESSMENTS_TO_SAVE: 'assessments_to_save',\n    DATABASE_EXPERIMENT_ID: 'database_experiment_index',\n    DATABASE_VIDEO_ID: 'database_video_index',\n    CURRENT_BITRATE: 'current_bitrate',\n    DEVICE_ID: 'device_id',\n    TESTER_ID: 'tester_id',\n    PAIR_ID: 'pair_id',\n    EXPERIMENT_TYPE: 'experiment_type',\n    VIDEO_COUNT: 'video_count',\n    VIDEO_LIMIT: 'video_limit',\n    //VIDEO_URLS: 'video_urls', // TO BE DELETED\n    RUNNING: 'running',\n    //BITRATE_MODE: 'bitrate_mode',\n    EXTENSION_MODE: \"extension_mode\",\n    CONFIGURATION: \"configuration\"\n};\nexport const CONFIGURATION_KEYS = {\n    TITLE: \"title\",\n    DESCRIPTION: \"description\",\n    BITRATE_INTERVAL: \"bitrate_interval\",\n    ASSESSMENT_INTERVAL: \"assessment_interval\",\n    VIDEOS: \"videos\",\n    VIDEO_KEYS: {\n        NAME: \"name\",\n        DESCRIPTION: \"description\",\n        URL: \"url\",\n        VMAF_TEMPLATE_SCENARIO: \"vmaf_template_scenario\",\n        BITRATE_VMAF_MAP: \"bitrate_vmaf_map\",\n        SCENARIO: \"scenario\",\n    }\n};\nexport const STORAGE_DEFAULT = {\n    [STORAGE_KEYS.DATABASE_EXPERIMENT_ID]: null,\n    [STORAGE_KEYS.DATABASE_VIDEO_ID]: null,\n    [STORAGE_KEYS.CURRENT_BITRATE]: null,\n    [STORAGE_KEYS.VIDEO_COUNT]: 0,\n    [STORAGE_KEYS.DEVICE_ID]: 106,\n    [STORAGE_KEYS.TESTER_ID]: 'dev_tester',\n    [STORAGE_KEYS.EXPERIMENT_TYPE]: 'alone',\n    [STORAGE_KEYS.VIDEO_LIMIT]: 1,\n    [STORAGE_KEYS.RUNNING]: false,\n    [STORAGE_KEYS.EXTENSION_MODE]: \"experiment\",\n    [STORAGE_KEYS.CONFIGURATION]: DEFAULT_EXPERIMENT_CONFIGURATION\n};\nexport const EXTENSION_MODE_AVAILABLE = {\n    EXPERIMENT: \"experiment\",\n    MAPPING: \"mapping\"\n};\nexport const MESSAGE_TEMPLATE = {\n    HEADER: 'header',\n    DATA: 'data',\n    ARCHIVE: 'archive',\n};\nexport const MESSAGE_HEADERS = {\n    START_ANALYZING: 'start_analyzing',\n    NERD_STATISTICS: 'nerdstats',\n    ASSESSMENT: 'assessment',\n    FINISHED: 'finished',\n    CREDITS: 'credits',\n    REDIRECT: 'redirect'\n};\n","import { MESSAGE_HEADERS, MESSAGE_TEMPLATE } from \"../../config/config\";\nimport { Controller } from \"./modules/Controller\";\nimport { STORAGE_DEFAULT } from \"../../config/config\";\nimport { get_local_datetime } from \"../../utils/time_utils\";\n/**\n * Detect extension reloads and perform actions.\n * This listener callback executes only when extension is installed or reloaded.\n*/\nchrome.runtime.onInstalled.addListener(() => {\n    console.log(`[BackgroundScript] | ${get_local_datetime(new Date())} | Installing...`);\n    // Initialize local storage || WARNING --> THIS RESETS ALL chrome.storage KEYS TO DEFAULT VALUES\n    chrome.storage.local.set(STORAGE_DEFAULT);\n});\nchrome.action.onClicked.addListener(async (tab) => {\n    const t = tab;\n    await chrome.tabs.update(tab.id, {\n        url: \"setup.html\"\n    });\n});\n/** Message listeners\n * DO NOT USE await inside onMessage listener callback's body.\n * REMEMBER to return true at the end of the onMessage listener callback's body.\n *\n * Returning true at the end tells the other side of connection to wait for response\n * that will asynchronously, that is why sendResponse is mandatory.\n * Using await inside callback's body would result in errors.\n*/\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    // do not use async/await within listener callback\n    /*no await!!!*/ receive_finished_signal(message, sender, sendResponse);\n    /*no await!!!*/ receive_redirect_signal(message, sender, sendResponse);\n    return true; // return true is essential to indicate that response will be sent asynchronously\n});\n// Initialize Controller instance\nconst controller = new Controller();\ncontroller.init();\n/**\n * Function checks if received message is signal indicating end of video\n * Redirects the tab that the message came from to the custom web page\n * REMEMBER to use sendResponse !!!\n*/\nconst receive_finished_signal = async (message, sender, sendResponse) => {\n    if (message[MESSAGE_TEMPLATE.HEADER] === MESSAGE_HEADERS.FINISHED) {\n        // Redirect to custom webpage\n        if (sender.tab) {\n            const tabId = sender.tab.id;\n            await chrome.tabs.update(tabId, {\n                url: \"break.html\"\n            });\n            sendResponse({ msg: \"Finish signal received\" }); // Essential sendResponse\n        }\n    }\n};\nconst receive_redirect_signal = async (message, sender, sendResponse) => {\n    if (message[MESSAGE_TEMPLATE.HEADER] === MESSAGE_HEADERS.REDIRECT) {\n        if (sender.tab) {\n            const tabId = sender.tab.id;\n            await chrome.tabs.update(tabId, {\n                url: message.data.url\n            });\n            sendResponse({ msg: \"Redirect signal received\" });\n        }\n    }\n};\n","import { EXTENSION_MODE_AVAILABLE, STORAGE_KEYS } from \"../../../config/config\";\nimport { CustomLogger } from \"../../../utils/CustomLogger\";\nexport class Controller {\n    constructor() {\n        this.NETFLIX_WATCH_URL = \"https://www.netflix.com/watch\";\n        this.logger = new CustomLogger(\"[Controller]\");\n    }\n    async init() {\n        this.logger.log(\"Initializing...\");\n        this.listenForVideoStart();\n    }\n    async injectScript(tabId) {\n        const running = (await chrome.storage.local.get([STORAGE_KEYS.RUNNING]))[STORAGE_KEYS.RUNNING];\n        const mode = (await chrome.storage.local.get([STORAGE_KEYS.EXTENSION_MODE]))[STORAGE_KEYS.EXTENSION_MODE];\n        if (running === false) {\n            this.logger.log(\"Extension is not running.\");\n            return;\n        }\n        // Increase video count\n        /**\n         *\n        */\n        await this.increaseVideoCount();\n        // Define conent script file\n        let content_script;\n        if (mode === EXTENSION_MODE_AVAILABLE.EXPERIMENT) {\n            this.logger.log(\"Experiment mode detected. Switching to mainContentScript.bundle.js\");\n            content_script = \"mainContentScript.bundle.js\";\n        }\n        else if (mode === EXTENSION_MODE_AVAILABLE.MAPPING) {\n            this.logger.log(\"Mapping mode detected. Switching to mapperContentScript.bundle.js\");\n            content_script = \"mapperContentScript.bundle.js\";\n        }\n        else\n            (this.logger.log(\"Content script is incorrect!!!\"));\n        await chrome.scripting.executeScript({\n            target: {\n                tabId: tabId\n            },\n            files: [content_script] // ContentScript filename has to match names in webpack.config.js\n        });\n        this.logger.log(\"ContentScript has been injected\");\n    }\n    /**\n     *  Method that keeps track of videos order and limit.\n     *  For the first video in queue the count will be 1 but its index in an array is 0.\n     *  Video count is increased just before injecting the ContentScript.\n     *  It means that n-th video in row has the count of n for the enterity of playback. The index is n-1\n    */\n    async increaseVideoCount() {\n        const count = (await chrome.storage.local.get([STORAGE_KEYS.VIDEO_COUNT]))[STORAGE_KEYS.VIDEO_COUNT];\n        const new_count = count + 1;\n        this.logger.log(`Increasing video count to ${new_count}`);\n        await chrome.storage.local.set({\n            [STORAGE_KEYS.VIDEO_COUNT]: new_count\n        });\n    }\n    listenForVideoStart() {\n        // Code below seems to be the right solution //\n        // onHistoryStateUpdated detects navigation within Netlifx player (next video button)\n        /*\n        chrome.webNavigation.onHistoryStateUpdated.addListener((details) => {\n            this.logger.log(`ON HISTORY STATE UPDATED`)\n            console.log(details)\n            if(details.frameId === 0 && details.url.includes(this.NETFLIX_WATCH_URL)) {\n                chrome.tabs.get(details.tabId, async (tab) => {\n                    if(tab.url === details.url) {\n                        this.logger.log(\"Entered Netflix Video Player\")\n                        await this.injectScript(details.tabId)\n                    }\n                });\n            }\n        });\n        */\n        // onCompleted detects navigation using chrome.tabs.update\n        chrome.webNavigation.onCompleted.addListener(details => {\n            this.logger.log(`ON COMPLETED`);\n            this.logger.log(details);\n            if (details.frameId === 0 && details.url.includes(this.NETFLIX_WATCH_URL)) {\n                chrome.tabs.get(details.tabId, async (tab) => {\n                    if (tab.url === details.url) {\n                        this.logger.log(\"Entered Netflix Video Player\");\n                        await this.injectScript(details.tabId);\n                    }\n                });\n            }\n        });\n    }\n}\n","export const get_local_datetime = (object) => {\n    const year = object.getFullYear();\n    const month = (object.getMonth() + 1).toString().padStart(2, \"0\");\n    const day = object.getDate().toString().padStart(2, \"0\");\n    const hours = object.getHours().toString().padStart(2, \"0\");\n    const minutes = object.getMinutes().toString().padStart(2, \"0\");\n    const seconds = object.getSeconds().toString().padStart(2, \"0\");\n    const milliseconds = object.getMilliseconds().toString().padStart(3, \"0\");\n    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${milliseconds}`; // <-- Local datetime in extended ISO format ''YYYY-MM-DDTHH:MM:SS:XXX''\n};\nexport const get_local_datetime_and_timezone = (object) => {\n    // Get the datetime\n    const year = object.getFullYear();\n    const month = (object.getMonth() + 1).toString().padStart(2, \"0\");\n    const day = object.getDate().toString().padStart(2, \"0\");\n    const hours = object.getHours().toString().padStart(2, \"0\");\n    const minutes = object.getMinutes().toString().padStart(2, \"0\");\n    const seconds = object.getSeconds().toString().padStart(2, \"0\");\n    const milliseconds = object.getMilliseconds().toString().padStart(3, \"0\");\n    const datetime = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${milliseconds}`;\n    // Get timezone offset in +/- HH:MM format\n    const timezone_offset_min = object.getTimezoneOffset();\n    const offset_hrs = Math.abs(timezone_offset_min / 60);\n    const offset_min = Math.abs(timezone_offset_min % 60);\n    if (timezone_offset_min <= 0) {\n        const timezone_standard = \"+\" + offset_hrs.toString().padStart(2, \"0\") + \":\" + offset_min.toString().padStart(2, \"0\");\n        return datetime + timezone_standard;\n    }\n    else {\n        const timezone_standard = \"-\" + offset_hrs.toString().padStart(2, \"0\") + \":\" + offset_min.toString().padStart(2, \"0\");\n        return datetime + timezone_standard;\n    }\n};\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.h = () => (\"e29d13a3b8e442e64546\")","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"names":[],"sourceRoot":""}